# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DemComperatorDialog
                                 A QGIS plugin
 this tool compares DEMs
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-05-03
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Jeroen Goossens
        email                : jeroen.goossens@student.kuleuven.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import qgis
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import *
from qgis import processing
from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry
from qgis.gui import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.utils import *
import matplotlib.pyplot as plt
import numpy as np
from osgeo import gdal
from numpy import array
import matplotlib.cm as cm
from PyQt5.QtWidgets import QDialog, QApplication, QFileDialog

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'DEM_dialog_base.ui'))


class DemComperatorDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(DemComperatorDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.BrowseDEM.clicked.connect(self.browseDEM)
        self.BrowseReference.clicked.connect(self.browseReference)
        self.Runbutton.clicked.connect(self.run)
        self.BrowseOutputDEM.clicked.connect(self.browseOutputDEM)
        self.BrowseOutputSlope.clicked.connect(self.browseOutputSlope)

    def browseDEM(self):
        fname1=QFileDialog.getOpenFileName(self,'Open File','D:\Program Files (x86)\Documenten\#Masterproef',)
        self.DEMfiletext.setText(fname1[0])
        lyr1=self.DEMfiletext.text()
        

    def browseReference(self):
        fname2=QFileDialog.getOpenFileName(self,'Open File','D:\Program Files (x86)\Documenten\#Masterproef',)
        self.referencefiletext.setText(fname2[0])
        lyr2=self.referencefiletext.text()
        
    def browseOutputDEM(self):
        fname3=QFileDialog.getSaveFileName(self,'Open File','D:\Program Files (x86)\Documenten\#Masterproef','*.tif')
        self.OutputDEMfiletext.setText(fname3[0])
        Output=self.OutputDEMfiletext.text()

    def browseOutputSlope(self):
        fname4=QFileDialog.getSaveFileName(self,'Open File','D:\Program Files (x86)\Documenten\#Masterproef','*.tif')
        self.OutputSlopefiletext.setText(fname4[0])
        Slope=self.OutputSlopefiletext.text()        

    def run(self) :
        
        if self.GeiodHeightincluded.isChecked():
            GeoidH=self.GeoidHeightValue.value()
        else:
            GeoidH=0
        print(GeoidH)
        slopeclasses=self.slopeclassesValue.value()
        lyr1=self.DEMfiletext.text()
        lyr2=self.referencefiletext.text()
        Output=self.OutputDEMfiletext.text()
        slope=self.OutputSlopefiletext.text() 

        layer=iface.addRasterLayer(lyr1,'')
        layer1=QgsRasterLayer(lyr1)
        layer=iface.addRasterLayer(lyr2,'')
        layer2=QgsRasterLayer(lyr2)
        processing.run('gdal:slope', {'INPUT':lyr2, 'ZEVENBERGEN' : True,'AS_PERCENT' : True,'BAND':1,'OUTPUT':slope})
        layer=iface.addRasterLayer(slope,'')

        entries = []
        #Rastercalculator
        ras = QgsRasterCalculatorEntry()
        ras.ref = 'ras@1'
        ras.raster = layer1
        ras.bandNumber = 1
        entries.append(ras)

        ras = QgsRasterCalculatorEntry()
        ras.ref = 'ras@2'
        ras.raster = layer2
        ras.bandNumber = 1
        entries.append(ras)

        calc = QgsRasterCalculator('ras@1- ras@2-{}'.format(GeoidH),Output, 'GTiff', layer2.extent(),\
        layer2.width(),layer2.height(), entries)
        calc.processCalculation()
        layer4=QgsRasterLayer(Output)
        layer=iface.addRasterLayer(Output,'')

        #make DEM array
        ds = gdal.Open(Output)
        b=ds.GetRasterBand(1)
        myarray = np.array(b.ReadAsArray())
        nodata = b.GetNoDataValue()
        rasterArray = np.ma.masked_equal(myarray, nodata)
        data=myarray

        #make slope array
        ds = gdal.Open(slope)
        b=ds.GetRasterBand(1)
        myarray = np.array(b.ReadAsArray())
        nodata = b.GetNoDataValue()
        sloperasterArray = np.ma.masked_equal(myarray, nodata)
        arr=myarray

        # trasform -9999 in nan
        indici = np.where((arr< -100))
        ix = indici[1]  # x index
        iy = indici[0]  # y index
        arr[iy, ix] = float('NaN')

        indici = np.where((data< -100)|(data>100))
        ix = indici[1]  # x index
        iy = indici[0]  # y index
        data[iy, ix] = float('NaN')
        print(len(ix),"outliers")
        print(len(ix)/np.size(data),"%") 

        # statistics
        def LE(data, LE_value):
            Threshold_zmin = (100 - LE_value) / 2.0
            Threshold_zmax = Threshold_zmin + LE_value
            percentile_min = np.nanpercentile(data, Threshold_zmin)
            percentile_max = np.nanpercentile(data, Threshold_zmax)
            LE = (percentile_max - percentile_min) / 2.0
            return LE

        def NMAD(data):
            median = np.nanmedian(data)
            MAD = np.absolute(data - median)
            NMAD = 1.4826 * np.nanmedian(MAD)
            return NMAD
 
        i=0
        perc=np.nanpercentile(arr,2)
        X=[]
        Y=np.zeros((slopeclasses,9))
        while i < slopeclasses:
            i=i+1
            X.append('classe'+str(i))
            preperc=perc
            perc=np.nanpercentile(arr,i*100/slopeclasses)
            clasdata=np.where((arr > preperc)&(arr < perc),data,np.nan)
            mean = np.nanmean(clasdata)
            std = np.nanstd(clasdata)
            RMSE = np.sqrt(mean ** 2 + std ** 2)
            median = np.nanmedian(clasdata) 
            nmad = NMAD(clasdata)
            le68 = LE(clasdata, 68)
            le90 = LE(clasdata, 90)
            max = np.nanmax(clasdata)
            min = np.nanmin(clasdata)
            Y[i-1,:]=[mean,std,RMSE,median,nmad,le68,le90,max,min]

        width =0.2
        width2 = 0.02
        i=0
        while i< slopeclasses:
            plt.figure('Histogram')
            plt.title('statistics')
            plt.bar(X[i],Y[i,1],width,bottom=Y[i,0],align='center',color="r")
            plt.bar(X[i],-Y[i,1],width,bottom=Y[i,0],align='center',color="r")
            plt.bar(X[i],-Y[i,6],width2,bottom=Y[i,0],align='center',color="r")
            plt.bar(X[i],Y[i,6],width2,bottom=Y[i,0],align='center',color="r")
            plt.plot(X[i],Y[i,0],"bs",label="mean")
            plt.plot(X[i],Y[i,3],"yv",label="median")
            plt.plot(X[i],Y[i,0]+Y[i,6],"k_",label="mean+le90")
            plt.plot(X[i],Y[i,0]-Y[i,6],"g_",label="mean-le90")
            plt.plot(X[i],Y[i,0]+Y[i,4],"cx",label="mean+nmad")
            plt.plot(X[i],Y[i,0]-Y[i,4],"mx",label="mean-nmad")
            plt.plot(X[i],Y[i,0]+Y[i,1],"c.",label="mean+std")
            plt.plot(X[i],Y[i,0]-Y[i,1],"m.",label="mean-std")
            i=i+1
        plt.xlabel('Value')
        plt.ylabel('Frequency')
        plt.xticks(X, rotation='vertical')
        plt.legend(bbox_to_anchor=(1.04,1))
        plt.show()